import {resolve} from 'node:path'
import {type Plugin, type ResolvedConfig} from 'vite'
import fs from 'node:fs'
import {type Data} from 'vite-plugin-i18n'
import {transformLocalize} from './transform-localize'
// import {walk} from 'estree-walker'

/**
 * TODO
 *
 * - [ ] in client builds, replace `_` and `localize` template tags with a
 *   function named `__$LOCALIZE$__(key, ...params)` or with
 *   `intperolate(__$LOCALIZE$__(key), ...params)` calls
 * - [ ] in client strip the setLocaleGetter and setDefaultLocale calls, and
 * - [ ] after the client build, for each locale, replace `__$LOCALIZE$__` calls
 *   with the corresponding template string; replace `__$LOCALE$__` with the
 *   locale
 * - [ ] track missing and unused translations
 * - [ ] optionally add missing translations to the locale files
 * - [ ] optionally move unused translations to a `unused{}` in the locale files
 * - [ ] optionally warn about dynamic translations
 */

type Options = {
	locales?: string[]
	localesDir?: string
	defaultLocale?: string
}

const c = (...args: any[]): any => {
	console.log('vite i18n', ...args)
	return args[0]
}

export function i18nPlugin(options: Options = {}): Plugin {
	const {localesDir = 'i18n'} = options
	const locales = options.locales || ['en']
	const defaultLocale = options.defaultLocale || locales[0]
	const localeNames = {}
	const localesDirAbs = resolve(process.cwd(), localesDir)
	// c({locales, localesDirAbs, defaultLocale})
	let shouldInline = false
	return {
		name: 'i18n',
		enforce: 'pre',
		configResolved(config) {
			// c('entries', config.build)
			// shouldInline = !!config.build.ssr || !config.isProduction
		},
		buildEnd(...args) {
			// c('buildEnd', args)
		},
		buildStart(options) {
			// c('buildStart', options)
			// Ensure the locales dir exists
			fs.mkdirSync(localesDirAbs, {recursive: true})
			// Verify/generate the locale files
			const fallbacks = {}
			for (const locale of locales!) {
				const match = /^([a-z]{2})([_-]([A-Z]{2}))?$/.exec(locale)
				if (!match)
					throw new Error(
						`Invalid locale: ${locale} (does not match xx or xx_XX))`
					)
				const localeFile = resolve(localesDirAbs, `${locale}.json`)
				let data: Data
				if (fs.existsSync(localeFile)) {
					data = JSON.parse(fs.readFileSync(localeFile, 'utf8')) as Data
					if (data.locale !== locale)
						throw new Error(
							`Invalid locale file: ${localeFile} (locale mismatch ${data.locale} !== ${locale})`
						)
					if (!data.name)
						data.name = match[3] ? `${match[1]} (${match[3]})` : locale
					if (data.fallback) {
						if (!locales!.includes(data.fallback))
							throw new Error(
								`Invalid locale file: ${localeFile} (invalid fallback ${data.fallback})`
							)
						let follow
						while ((follow = fallbacks[data.fallback])) {
							if (follow === locale) {
								throw new Error(
									`Invalid locale file: ${localeFile} (circular fallback ${data.fallback})`
								)
							}
						}
						fallbacks[locale] = data.fallback
					}
				} else {
					data = {
						locale,
						name: match[3] ? `${match[1]} (${match[3]})` : locale,
						translations: {},
					}
					fs.writeFileSync(localeFile, JSON.stringify(data, null, 2))
				}
				localeNames[locale] = data.name
			}
		},
		async resolveId(id) {
			// c('resolveId', id, importer, await this.getModuleInfo(id))
			if (id.includes('/i18n/__locales.')) return '\0i18n-locales.js'
			if (id.includes('/i18n/__data.')) return '\0i18n-data.js'
			if (id.includes('/i18n/__state.')) return '\0i18n-state.js'
		},
		async load(id) {
			// c('load', id, await this.getModuleInfo(id))
			if (id === '\0i18n-locales.js') {
				return shouldInline
					? ''
					: `
/**
 * This file was generated by vite-plugin-i18n.
 *
 * For server builds, it contains all translations. For client builds, it is
 * empty, and translations need to be loaded dynamically.
 */
${locales!
	.map(l => `export {default as ${l}} from '${localesDirAbs}/${l}.json'`)
	.join('\n')}
`
			}
			if (id === '\0i18n-data.js') {
				return `
/** This file is generated at build time by \`vite-plugin-i18n\`. */
/** @type {import('vite-plugin-i18n').Locale[]} */
export const locales = ${JSON.stringify(locales)}
/** @type {Record<import('vite-plugin-i18n').Locale, string>} */
export const localeNames = ${JSON.stringify(localeNames)}
`
			}
			if (id === '\0i18n-state.js') {
				return `
/** This file is generated at build time by \`vite-plugin-i18n\`. */
import {localeNames} from '/i18n/__data.js'

/** @typedef {import('vite-plugin-i18n').Locale} Locale */
/** @type {Locale} */
export let defaultLocale = ${
					shouldInline ? '__$LOCALE$__' : JSON.stringify(defaultLocale)
				}
/** @type {Locale} */
export let currentLocale = defaultLocale

const _checkLocale = l => {
	if (!localeNames[l]) throw new TypeError(\`unknown locale \${l}\`)
}
/** @type {(locale: Locale) => void} */
export const setDefaultLocale = l => {
	_checkLocale(l)
	defaultLocale = l
}
export let getLocale = () => defaultLocale
/** @type {(fn: () => Locale | undefined) => void} */
export const setLocaleGetter = fn => {
	getLocale = () => {
		const l = fn() || defaultLocale
		_checkLocale(l)
		currentLocale = l
	  return l
	}
}
`
			}
		},
		async transform(code, id) {
			if (
				!/\.(cjs|js|mjs|ts|jsx|tsx)($|\?)/.test(id) ||
				!code.slice(0, 5000).includes('vite-plugin-i18n')
			)
				return null
			// c('transform', id, await this.getModuleInfo(id))

			return null
			const ast = this.parse(code)
			// @ts-ignore
			ast.body.forEach(node => {
				if (
					node.type === 'ImportDeclaration' &&
					node.source.value === 'vite-plugin-i18n'
				) {
					c(node.specifiers)
					// node.specifiers.forEach(specifier => {
					// })
				}
			})
			return null
			let importedFunctionName = '_'
			const isI18nTemplate = node =>
				node.type === 'TaggedTemplateExpression' &&
				node.tag.name === importedFunctionName && // Check against the imported function name
				node.quasi.type === 'TemplateLiteral'

			// Traverse the AST to find the import statement and extract the function name
			// @ts-ignore
			ast.body.forEach(node => {
				if (
					node.type === 'ImportDeclaration' &&
					node.source.value === 'vite-plugin-i18n'
				) {
					// Find the import specifier with the imported function name
					const specifier = node.specifiers.find(
						spec => spec.imported && spec.imported.name === '_'
					)

					if (specifier) {
						importedFunctionName = specifier.local.name
					}
				}
			})

			// if (id.endsWith('.js')) {
			// 	// Apply flavor-specific transformations here
			// 	const transformedCode = code.replace(
			// 		'$localize',
			// 		'/* flavor: $localize */'
			// 	)
			// 	return {
			// 		code: transformedCode,
			// 		map: null, // You might need to handle source maps
			// 	}
			// }
			return null
		},
		// resolveId(source, importer) {
		// 	// Resolve flavor imports to their corresponding plain IDs
		// 	if (source.startsWith('\0')) {
		// 		const [flavor, plainId] = source.slice(1).split('-')
		// 		return this.resolve(plainId, importer, {skipSelf: true}).then(
		// 			resolved => {
		// 				return {
		// 					id: `\0${flavor}-${resolved.id}`,
		// 					external: true, // Ensure Vite doesn't try to bundle this import
		// 				}
		// 			}
		// 		)
		// 	}
		// 	return null
		// },
	}
}
